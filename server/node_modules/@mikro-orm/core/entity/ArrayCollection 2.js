"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayCollection = void 0;
const util_1 = require("util");
const Reference_1 = require("./Reference");
const wrap_1 = require("./wrap");
const enums_1 = require("../enums");
const errors_1 = require("../errors");
const Utils_1 = require("../utils/Utils");
class ArrayCollection {
    constructor(owner, items) {
        this.owner = owner;
        this.items = new Set();
        this.initialized = true;
        this.dirty = false;
        /* istanbul ignore next */
        if (items) {
            let i = 0;
            this.items = new Set(items);
            this.items.forEach(item => this[i++] = item);
        }
    }
    async loadCount() {
        return this.items.size;
    }
    getItems() {
        return [...this.items];
    }
    toArray() {
        if (this.items.size === 0) {
            return [];
        }
        const meta = this.property.targetMeta;
        const args = [...meta.toJsonParams.map(() => undefined)];
        return this.getItems().map(item => (0, wrap_1.wrap)(item).toJSON(...args));
    }
    toJSON() {
        return this.toArray();
    }
    getIdentifiers(field) {
        const items = this.getItems();
        if (items.length === 0) {
            return [];
        }
        field ?? (field = this.property.targetMeta.serializedPrimaryKey);
        return items.map(i => {
            if (Utils_1.Utils.isEntity(i[field], true)) {
                return (0, wrap_1.wrap)(i[field], true).getPrimaryKey();
            }
            return i[field];
        });
    }
    add(...items) {
        for (const item of items) {
            const entity = Reference_1.Reference.unwrapReference(item);
            if (!this.contains(entity, false)) {
                this.incrementCount(1);
                this[this.items.size] = entity;
                this.items.add(entity);
                this.propagate(entity, 'add');
            }
        }
    }
    set(items) {
        this.remove(...this.items);
        this.add(...items);
    }
    /**
     * @internal
     */
    hydrate(items) {
        for (let i = 0; i < this.items.size; i++) {
            delete this[i];
        }
        this.items.clear();
        this._count = 0;
        this.add(...items);
    }
    /**
     * Remove specified item(s) from the collection. Note that removing item from collection does necessarily imply deleting the target entity,
     * it means we are disconnecting the relation - removing items from collection, not removing entities from database - `Collection.remove()`
     * is not the same as `em.remove()`. If we want to delete the entity by removing it from collection, we need to enable `orphanRemoval: true`,
     * which tells the ORM we don't want orphaned entities to exist, so we know those should be removed.
     */
    remove(...items) {
        for (const item of items) {
            if (!item) {
                continue;
            }
            const entity = Reference_1.Reference.unwrapReference(item);
            if (this.items.delete(entity)) {
                this.incrementCount(-1);
                delete this[this.items.size]; // remove last item
                Object.assign(this, [...this.items]); // reassign array access
                this.propagate(entity, 'remove');
            }
        }
    }
    /**
     * Remove all items from the collection. Note that removing items from collection does necessarily imply deleting the target entity,
     * it means we are disconnecting the relation - removing items from collection, not removing entities from database - `Collection.remove()`
     * is not the same as `em.remove()`. If we want to delete the entity by removing it from collection, we need to enable `orphanRemoval: true`,
     * which tells the ORM we don't want orphaned entities to exist, so we know those should be removed.
     */
    removeAll() {
        this.remove(...this.items);
    }
    /**
     * @internal
     */
    removeWithoutPropagation(entity) {
        if (!this.items.delete(entity)) {
            return;
        }
        this.incrementCount(-1);
        delete this[this.items.size];
        Object.assign(this, [...this.items]);
    }
    contains(item, check) {
        const entity = Reference_1.Reference.unwrapReference(item);
        return this.items.has(entity);
    }
    count() {
        return this.items.size;
    }
    isInitialized(fully = false) {
        if (fully) {
            return this.initialized && [...this.items].every((item) => (0, wrap_1.helper)(item).__initialized);
        }
        return this.initialized;
    }
    isDirty() {
        return this.dirty;
    }
    setDirty(dirty = true) {
        this.dirty = dirty;
    }
    get length() {
        return this.count();
    }
    *[Symbol.iterator]() {
        for (const item of this.items) {
            yield item;
        }
    }
    /**
     * @internal
     */
    get property() {
        if (!this._property) {
            const meta = (0, wrap_1.helper)(this.owner).__meta;
            /* istanbul ignore if */
            if (!meta) {
                throw errors_1.MetadataError.fromUnknownEntity(this.owner.constructor.name, 'Collection.property getter, maybe you just forgot to initialize the ORM?');
            }
            const field = Object.keys(meta.properties).find(k => this.owner[k] === this);
            this._property = meta.properties[field];
        }
        return this._property;
    }
    propagate(item, method) {
        if (this.property.owner && this.property.inversedBy) {
            this.propagateToInverseSide(item, method);
        }
        else if (!this.property.owner && this.property.mappedBy) {
            this.propagateToOwningSide(item, method);
        }
    }
    propagateToInverseSide(item, method) {
        const collection = item[this.property.inversedBy];
        if (this.shouldPropagateToCollection(collection, method)) {
            collection[method](this.owner);
        }
    }
    propagateToOwningSide(item, method) {
        const collection = item[this.property.mappedBy];
        if (this.property.reference === enums_1.ReferenceType.MANY_TO_MANY) {
            if (this.shouldPropagateToCollection(collection, method)) {
                collection[method](this.owner);
            }
        }
        else if (this.property.reference === enums_1.ReferenceType.ONE_TO_MANY && method !== 'takeSnapshot' && !(this.property.orphanRemoval && method === 'remove')) {
            const prop2 = this.property.targetMeta.properties[this.property.mappedBy];
            const owner = prop2.mapToPk ? (0, wrap_1.helper)(this.owner).getPrimaryKey() : this.owner;
            const value = method === 'add' ? owner : null;
            // skip if already propagated
            if (Reference_1.Reference.unwrapReference(item[this.property.mappedBy]) !== value) {
                item[this.property.mappedBy] = value;
            }
        }
    }
    shouldPropagateToCollection(collection, method) {
        if (!collection) {
            return false;
        }
        switch (method) {
            case 'add':
                return !collection.contains(this.owner, false);
            case 'remove':
                return collection.isInitialized() && collection.contains(this.owner, false);
            case 'takeSnapshot':
                return collection.isDirty();
        }
    }
    incrementCount(value) {
        if (typeof this._count === 'number') {
            this._count += value;
        }
    }
    [util_1.inspect.custom](depth) {
        const object = { ...this };
        const hidden = ['items', 'owner', '_property', '_count', 'snapshot', '_populated', '_lazyInitialized'];
        hidden.forEach(k => delete object[k]);
        const ret = (0, util_1.inspect)(object, { depth });
        const name = `${this.constructor.name}<${this.property.type}>`;
        return ret === '[Object]' ? `[${name}]` : name + ' ' + ret;
    }
}
exports.ArrayCollection = ArrayCollection;
Object.defineProperties(ArrayCollection.prototype, {
    __collection: { value: true, enumerable: false, writable: false },
});
