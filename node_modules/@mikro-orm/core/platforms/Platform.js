"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Platform = exports.JsonProperty = void 0;
const clone_1 = require("../utils/clone");
const entity_1 = require("../entity");
const naming_strategy_1 = require("../naming-strategy");
const ExceptionConverter_1 = require("./ExceptionConverter");
const types_1 = require("../types");
const Utils_1 = require("../utils/Utils");
const enums_1 = require("../enums");
exports.JsonProperty = Symbol('JsonProperty');
class Platform {
    constructor() {
        this.exceptionConverter = new ExceptionConverter_1.ExceptionConverter();
    }
    usesPivotTable() {
        return false;
    }
    supportsTransactions() {
        return true;
    }
    usesImplicitTransactions() {
        return true;
    }
    getNamingStrategy() {
        return naming_strategy_1.UnderscoreNamingStrategy;
    }
    usesReturningStatement() {
        return false;
    }
    usesCascadeStatement() {
        return false;
    }
    getSchemaHelper() {
        return undefined;
    }
    indexForeignKeys() {
        return false;
    }
    allowsMultiInsert() {
        return true;
    }
    /**
     * Whether or not the driver supports retuning list of created PKs back when multi-inserting
     */
    usesBatchInserts() {
        return true;
    }
    /**
     * Whether or not the driver supports updating many records at once
     */
    usesBatchUpdates() {
        return true;
    }
    usesDefaultKeyword() {
        return true;
    }
    /**
     * Normalizes primary key wrapper to scalar value (e.g. mongodb's ObjectId to string)
     */
    normalizePrimaryKey(data) {
        return data;
    }
    /**
     * Converts scalar primary key representation to native driver wrapper (e.g. string to mongodb's ObjectId)
     */
    denormalizePrimaryKey(data) {
        return data;
    }
    /**
     * Used when serializing via toObject and toJSON methods, allows to use different PK field name (like `id` instead of `_id`)
     */
    getSerializedPrimaryKeyField(field) {
        return field;
    }
    usesDifferentSerializedPrimaryKey() {
        return false;
    }
    /**
     * Returns the SQL specific for the platform to get the current timestamp
     */
    getCurrentTimestampSQL(length) {
        return 'current_timestamp' + (length ? `(${length})` : '');
    }
    getDateTimeTypeDeclarationSQL(column) {
        return 'datetime' + (column.length ? `(${column.length})` : '');
    }
    getDefaultDateTimeLength() {
        return 0;
    }
    getDateTypeDeclarationSQL(length) {
        return 'date' + (length ? `(${length})` : '');
    }
    getTimeTypeDeclarationSQL(length) {
        return 'time' + (length ? `(${length})` : '');
    }
    getRegExpOperator() {
        return 'regexp';
    }
    isAllowedTopLevelOperator(operator) {
        return operator === '$not';
    }
    quoteVersionValue(value, prop) {
        return value;
    }
    getDefaultVersionLength() {
        return 3;
    }
    allowsComparingTuples() {
        return true;
    }
    allowsUniqueBatchUpdates() {
        return true;
    }
    isBigIntProperty(prop) {
        return prop.columnTypes && prop.columnTypes[0] === 'bigint';
    }
    isRaw(value) {
        return typeof value === 'object' && value !== null && '__raw' in value;
    }
    getDefaultSchemaName() {
        return undefined;
    }
    getBooleanTypeDeclarationSQL() {
        return 'boolean';
    }
    getIntegerTypeDeclarationSQL(column) {
        return 'int';
    }
    getSmallIntTypeDeclarationSQL(column) {
        return 'smallint';
    }
    getMediumIntTypeDeclarationSQL(column) {
        return 'mediumint';
    }
    getTinyIntTypeDeclarationSQL(column) {
        return 'tinyint';
    }
    getBigIntTypeDeclarationSQL(column) {
        return 'bigint';
    }
    getVarcharTypeDeclarationSQL(column) {
        return `varchar(${column.length ?? 255})`;
    }
    getTextTypeDeclarationSQL(_column) {
        return `text`;
    }
    getEnumTypeDeclarationSQL(column) {
        if (column.items?.every(item => Utils_1.Utils.isString(item))) {
            return `enum('${column.items.join("', '")}')`;
        }
        return this.getTinyIntTypeDeclarationSQL(column);
    }
    getFloatDeclarationSQL() {
        return 'float';
    }
    getDoubleDeclarationSQL() {
        return 'double';
    }
    getDecimalTypeDeclarationSQL(column) {
        const precision = column.precision ?? 10;
        const scale = column.scale ?? 0;
        return `numeric(${precision},${scale})`;
    }
    getUuidTypeDeclarationSQL(column) {
        column.length ?? (column.length = 36);
        return this.getVarcharTypeDeclarationSQL(column);
    }
    extractSimpleType(type) {
        return type.toLowerCase().match(/[^(), ]+/)[0];
    }
    getMappedType(type) {
        const mappedType = this.config.get('discovery').getMappedType?.(type, this);
        return mappedType ?? this.getDefaultMappedType(type);
    }
    getDefaultMappedType(type) {
        if (type.endsWith('[]')) {
            return types_1.Type.getType(types_1.ArrayType);
        }
        switch (this.extractSimpleType(type)) {
            case 'string': return types_1.Type.getType(types_1.StringType);
            case 'varchar': return types_1.Type.getType(types_1.StringType);
            case 'text': return types_1.Type.getType(types_1.TextType);
            case 'number': return types_1.Type.getType(types_1.IntegerType);
            case 'bigint': return types_1.Type.getType(types_1.BigIntType);
            case 'smallint': return types_1.Type.getType(types_1.SmallIntType);
            case 'tinyint': return types_1.Type.getType(types_1.TinyIntType);
            case 'mediumint': return types_1.Type.getType(types_1.MediumIntType);
            case 'float': return types_1.Type.getType(types_1.FloatType);
            case 'double': return types_1.Type.getType(types_1.DoubleType);
            case 'integer': return types_1.Type.getType(types_1.IntegerType);
            case 'decimal':
            case 'numeric': return types_1.Type.getType(types_1.DecimalType);
            case 'boolean': return types_1.Type.getType(types_1.BooleanType);
            case 'blob':
            case 'buffer': return types_1.Type.getType(types_1.BlobType);
            case 'uuid': return types_1.Type.getType(types_1.UuidType);
            case 'date': return types_1.Type.getType(types_1.DateType);
            case 'datetime': return types_1.Type.getType(types_1.DateTimeType);
            case 'time': return types_1.Type.getType(types_1.TimeType);
            case 'object':
            case 'json': return types_1.Type.getType(types_1.JsonType);
            case 'enum': return types_1.Type.getType(types_1.EnumType);
            default: return types_1.Type.getType(types_1.UnknownType);
        }
    }
    getArrayDeclarationSQL() {
        return 'text';
    }
    marshallArray(values) {
        return values.join(',');
    }
    unmarshallArray(value) {
        if (value === '') {
            return [];
        }
        return value.split(',');
    }
    getBlobDeclarationSQL() {
        return 'blob';
    }
    getJsonDeclarationSQL() {
        return 'json';
    }
    getSearchJsonPropertySQL(path, type, aliased) {
        return path;
    }
    getSearchJsonPropertyKey(path, type, aliased) {
        return path.join('.');
    }
    getFullTextWhereClause(prop) {
        throw new Error('Full text searching is not supported by this driver.');
    }
    supportsCreatingFullTextIndex() {
        throw new Error('Full text searching is not supported by this driver.');
    }
    getFullTextIndexExpression(indexName, schemaName, tableName, columns) {
        throw new Error('Full text searching is not supported by this driver.');
    }
    convertsJsonAutomatically(marshall = false) {
        return !marshall;
    }
    getRepositoryClass() {
        return entity_1.EntityRepository;
    }
    getDefaultCharset() {
        return 'utf8';
    }
    getExceptionConverter() {
        return this.exceptionConverter;
    }
    getSchemaGenerator(driver, em) {
        throw new Error(`${driver.constructor.name} does not support SchemaGenerator`);
    }
    getEntityGenerator(em) {
        throw new Error(`${this.constructor.name} does not support EntityGenerator`);
    }
    getMigrator(em) {
        throw new Error(`${this.constructor.name} does not support Migrator`);
    }
    processDateProperty(value) {
        return value;
    }
    quoteIdentifier(id, quote = '`') {
        return `${quote}${id.replace('.', `${quote}.${quote}`)}${quote}`;
    }
    quoteValue(value) {
        return value;
    }
    cloneEmbeddable(data) {
        const copy = (0, clone_1.clone)(data);
        // tag the copy so we know it should be stringified when quoting (so we know how to treat JSON arrays)
        Object.defineProperty(copy, exports.JsonProperty, { enumerable: false, value: true });
        return copy;
    }
    setConfig(config) {
        this.config = config;
        this.namingStrategy = config.getNamingStrategy();
        if (this.config.get('forceUtcTimezone')) {
            this.timezone = 'Z';
        }
        else {
            this.timezone = this.config.get('timezone');
        }
    }
    getConfig() {
        return this.config;
    }
    isNumericColumn(mappedType) {
        return [types_1.IntegerType, types_1.SmallIntType, types_1.BigIntType].some(t => mappedType instanceof t);
    }
    supportsUnsigned() {
        return false;
    }
    /**
     * Returns the default name of index for the given columns
     */
    getIndexName(tableName, columns, type) {
        return this.namingStrategy.indexName(tableName, columns, type);
    }
    /* istanbul ignore next */
    getDefaultPrimaryName(tableName, columns) {
        return this.namingStrategy.indexName(tableName, columns, 'primary');
    }
    supportsCustomPrimaryKeyNames() {
        return false;
    }
    shouldHaveColumn(prop, populate, includeFormulas = true) {
        if (prop.formula) {
            return includeFormulas && (!prop.lazy || populate === true || (populate !== false && populate.some(p => p.field === prop.name)));
        }
        if (prop.persist === false) {
            return false;
        }
        if (prop.lazy && (populate === false || (populate !== true && !populate.some(p => p.field === prop.name)))) {
            return false;
        }
        if ([enums_1.ReferenceType.SCALAR, enums_1.ReferenceType.MANY_TO_ONE].includes(prop.reference)) {
            return true;
        }
        if (prop.reference === enums_1.ReferenceType.EMBEDDED) {
            return !!prop.object;
        }
        return prop.reference === enums_1.ReferenceType.ONE_TO_ONE && prop.owner;
    }
    /**
     * Currently not supported due to how knex does complex sqlite diffing (always based on current schema)
     */
    supportsDownMigrations() {
        return true;
    }
    validateMetadata(meta) {
        return;
    }
    /**
     * Generates a custom order by statement given a set of in order values, eg.
     * ORDER BY (CASE WHEN priority = 'low' THEN 1 WHEN priority = 'medium' THEN 2 ELSE NULL END)
     */
    generateCustomOrder(escapedColumn, values) {
        throw new Error('Not supported');
    }
    /**
     * @internal
     */
    castColumn(prop) {
        return '';
    }
}
exports.Platform = Platform;
