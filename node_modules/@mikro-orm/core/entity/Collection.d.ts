import type { AnyEntity, EntityDTO, FilterQuery, Loaded, LoadedCollection, Populate, ConnectionType } from '../typings';
import { ArrayCollection } from './ArrayCollection';
import type { LockMode, QueryOrderMap } from '../enums';
import { Reference } from './Reference';
import type { Transaction } from '../connections/Connection';
import type { FindOptions } from '../drivers/IDatabaseDriver';
export interface MatchingOptions<T extends object, P extends string = never> extends FindOptions<T, P> {
    where?: FilterQuery<T>;
    store?: boolean;
    ctx?: Transaction;
}
export declare class Collection<T extends object, O extends object = object> extends ArrayCollection<T, O> {
    private snapshot;
    private readonly?;
    private _populated;
    private _lazyInitialized;
    private _em?;
    constructor(owner: O, items?: T[], initialized?: boolean);
    /**
     * Creates new Collection instance, assigns it to the owning entity and sets the items to it (propagating them to their inverse sides)
     */
    static create<T extends object, O extends object = object>(owner: O, prop: keyof O, items: undefined | T[], initialized: boolean): Collection<T, O>;
    /**
     * Initializes the collection and returns the items
     */
    loadItems<P extends string = never>(options?: InitOptions<T, P>): Promise<Loaded<T, P>[]>;
    /**
     * Gets the count of collection items from database instead of counting loaded items.
     * The value is cached, use `refresh = true` to force reload it.
     */
    loadCount(refresh?: boolean): Promise<number>;
    matching<P extends string = never>(options: MatchingOptions<T, P>): Promise<Loaded<T, P>[]>;
    /**
     * Returns the items (the collection must be initialized)
     */
    getItems(check?: boolean): T[];
    toJSON(): EntityDTO<T>[];
    add(...items: (T | Reference<T & AnyEntity>)[]): void;
    set(items: (T | Reference<T & AnyEntity>)[]): void;
    /**
     * @internal
     */
    hydrate(items: T[], forcePropagate?: boolean): void;
    /**
     * @inheritDoc
     */
    remove(...items: (T | Reference<T & AnyEntity> | ((item: T) => boolean))[]): void;
    contains(item: (T | Reference<T & AnyEntity>), check?: boolean): boolean;
    count(): number;
    shouldPopulate(): boolean;
    populated(populated?: boolean): void;
    init<P extends string = never>(options?: InitOptions<T, P>): Promise<LoadedCollection<Loaded<T, P>>>;
    /**
     * @internal
     */
    takeSnapshot(forcePropagate?: boolean): void;
    /**
     * @internal
     */
    getSnapshot(): T[] | undefined;
    private getEntityManager;
    private createCondition;
    private createOrderBy;
    private createManyToManyCondition;
    private createLoadCountCondition;
    private modify;
    private checkInitialized;
    /**
     * re-orders items after searching with `$in` operator
     */
    private reorderItems;
    private cancelOrphanRemoval;
    private validateItemType;
    private validateModification;
}
export interface InitOptions<T, P extends string = never> {
    populate?: Populate<T, P>;
    orderBy?: QueryOrderMap<T> | QueryOrderMap<T>[];
    where?: FilterQuery<T>;
    lockMode?: Exclude<LockMode, LockMode.OPTIMISTIC>;
    connectionType?: ConnectionType;
}
