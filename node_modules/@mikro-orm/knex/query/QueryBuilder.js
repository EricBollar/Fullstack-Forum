"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryBuilder = void 0;
const core_1 = require("@mikro-orm/core");
const enums_1 = require("./enums");
const QueryBuilderHelper_1 = require("./QueryBuilderHelper");
const CriteriaNodeFactory_1 = require("./CriteriaNodeFactory");
/**
 * SQL query builder with fluent interface.
 *
 * ```ts
 * const qb = orm.em.createQueryBuilder(Publisher);
 * qb.select('*')
 *   .where({
 *     name: 'test 123',
 *     type: PublisherType.GLOBAL,
 *   })
 *   .orderBy({
 *     name: QueryOrder.DESC,
 *     type: QueryOrder.ASC,
 *   })
 *   .limit(2, 1);
 *
 * const publisher = await qb.getSingleResult();
 * ```
 */
class QueryBuilder {
    /**
     * @internal
     */
    constructor(entityName, metadata, driver, context, alias, connectionType, em) {
        this.metadata = metadata;
        this.driver = driver;
        this.context = context;
        this.connectionType = connectionType;
        this.em = em;
        /** @internal */
        this._populate = [];
        /** @internal */
        this._populateMap = {};
        this.aliasCounter = 0;
        this.flags = new Set([core_1.QueryFlag.CONVERT_CUSTOM_TYPES]);
        this.finalized = false;
        this._joins = {};
        this._explicitAlias = false;
        this._cond = {};
        this._orderBy = [];
        this._groupBy = [];
        this._having = {};
        this._joinedProps = new Map();
        this.subQueries = {};
        this._aliases = {};
        this.platform = this.driver.getPlatform();
        this.knex = this.driver.getConnection(this.connectionType).getKnex();
        if (alias) {
            this.aliasCounter++;
            this._explicitAlias = true;
        }
        // @ts-expect-error union type does not match the overloaded method signature
        this.from(entityName, alias);
    }
    get mainAlias() {
        if (!this._mainAlias) {
            this.throwNoFromClauseError();
        }
        return this._mainAlias;
    }
    get alias() {
        return this.mainAlias.aliasName;
    }
    get helper() {
        if (!this._helper) {
            this.throwNoFromClauseError();
        }
        return this._helper;
    }
    select(fields, distinct = false) {
        this._fields = core_1.Utils.asArray(fields);
        if (distinct) {
            this.flags.add(core_1.QueryFlag.DISTINCT);
        }
        return this.init(enums_1.QueryType.SELECT);
    }
    addSelect(fields) {
        if (this.type && this.type !== enums_1.QueryType.SELECT) {
            return this;
        }
        return this.select([...core_1.Utils.asArray(this._fields), ...core_1.Utils.asArray(fields)]);
    }
    insert(data) {
        return this.init(enums_1.QueryType.INSERT, data);
    }
    update(data) {
        return this.init(enums_1.QueryType.UPDATE, data);
    }
    delete(cond) {
        return this.init(enums_1.QueryType.DELETE, undefined, cond);
    }
    truncate() {
        return this.init(enums_1.QueryType.TRUNCATE);
    }
    count(field, distinct = false) {
        if (field) {
            this._fields = core_1.Utils.asArray(field);
        }
        else if (this.hasToManyJoins()) {
            this._fields = this.mainAlias.metadata.primaryKeys;
        }
        else {
            this._fields = [this.raw('*')];
        }
        if (distinct) {
            this.flags.add(core_1.QueryFlag.DISTINCT);
        }
        return this.init(enums_1.QueryType.COUNT);
    }
    join(field, alias, cond = {}, type = 'innerJoin', path) {
        this.joinReference(field, alias, cond, type, path);
        return this;
    }
    leftJoin(field, alias, cond = {}) {
        return this.join(field, alias, cond, 'leftJoin');
    }
    joinAndSelect(field, alias, cond = {}, type = 'innerJoin', path) {
        if (!this.type) {
            this.select('*');
        }
        const prop = this.joinReference(field, alias, cond, type, path);
        this.addSelect(this.getFieldsForJoinedLoad(prop, alias));
        const [fromAlias] = this.helper.splitField(field);
        const populate = this._joinedProps.get(fromAlias);
        const item = { field: prop.name, strategy: core_1.LoadStrategy.JOINED, children: [] };
        if (populate) {
            populate.children.push(item);
        }
        else { // root entity
            this._populate.push(item);
        }
        this._joinedProps.set(alias, item);
        return this;
    }
    leftJoinAndSelect(field, alias, cond = {}) {
        return this.joinAndSelect(field, alias, cond, 'leftJoin');
    }
    getFieldsForJoinedLoad(prop, alias) {
        const fields = [];
        prop.targetMeta.props
            .filter(prop => this.platform.shouldHaveColumn(prop, this._populate))
            .forEach(prop => fields.push(...this.driver.mapPropToFieldNames(this, prop, alias)));
        return fields;
    }
    withSubQuery(subQuery, alias) {
        this.subQueries[alias] = subQuery.toString();
        return this;
    }
    where(cond, params, operator) {
        if (core_1.Utils.isString(cond)) {
            cond = { [`(${cond})`]: core_1.Utils.asArray(params) };
            operator = operator || '$and';
        }
        else {
            cond = core_1.QueryHelper.processWhere({
                where: cond,
                entityName: this.mainAlias.entityName,
                metadata: this.metadata,
                platform: this.platform,
                aliasMap: this.getAliasMap(),
                aliased: !this.type || [enums_1.QueryType.SELECT, enums_1.QueryType.COUNT].includes(this.type),
                convertCustomTypes: this.flags.has(core_1.QueryFlag.CONVERT_CUSTOM_TYPES),
            });
        }
        const op = operator || params;
        const topLevel = !op || !core_1.Utils.hasObjectKeys(this._cond);
        const criteriaNode = CriteriaNodeFactory_1.CriteriaNodeFactory.createNode(this.metadata, this.mainAlias.entityName, cond);
        if ([enums_1.QueryType.UPDATE, enums_1.QueryType.DELETE].includes(this.type) && criteriaNode.willAutoJoin(this)) {
            // use sub-query to support joining
            this.setFlag(this.type === enums_1.QueryType.UPDATE ? core_1.QueryFlag.UPDATE_SUB_QUERY : core_1.QueryFlag.DELETE_SUB_QUERY);
            this.select(this.mainAlias.metadata.primaryKeys, true);
        }
        if (topLevel) {
            this._cond = criteriaNode.process(this);
        }
        else if (Array.isArray(this._cond[op])) {
            this._cond[op].push(criteriaNode.process(this));
        }
        else {
            const cond1 = [this._cond, criteriaNode.process(this)];
            this._cond = { [op]: cond1 };
        }
        if (this._onConflict) {
            this._onConflict[this._onConflict.length - 1].where = this._cond;
            this._cond = {};
        }
        return this;
    }
    andWhere(cond, params) {
        return this.where(cond, params, '$and');
    }
    orWhere(cond, params) {
        return this.where(cond, params, '$or');
    }
    orderBy(orderBy) {
        this._orderBy = [];
        core_1.Utils.asArray(orderBy).forEach(o => {
            const processed = core_1.QueryHelper.processWhere({
                where: o,
                entityName: this.mainAlias.entityName,
                metadata: this.metadata,
                platform: this.platform,
                aliasMap: this.getAliasMap(),
                aliased: !this.type || [enums_1.QueryType.SELECT, enums_1.QueryType.COUNT].includes(this.type),
                convertCustomTypes: false,
            });
            this._orderBy.push(CriteriaNodeFactory_1.CriteriaNodeFactory.createNode(this.metadata, this.mainAlias.entityName, processed).process(this));
        });
        return this;
    }
    groupBy(fields) {
        this._groupBy = core_1.Utils.asArray(fields);
        return this;
    }
    having(cond = {}, params) {
        if (core_1.Utils.isString(cond)) {
            cond = { [`(${cond})`]: core_1.Utils.asArray(params) };
        }
        this._having = CriteriaNodeFactory_1.CriteriaNodeFactory.createNode(this.metadata, this.mainAlias.entityName, cond).process(this);
        return this;
    }
    onConflict(fields = []) {
        this._onConflict = this._onConflict || [];
        this._onConflict.push({ fields: core_1.Utils.asArray(fields).map(f => f.toString()) });
        return this;
    }
    ignore() {
        if (!this._onConflict) {
            throw new Error('You need to call `qb.onConflict()` first to use `qb.ignore()`');
        }
        this._onConflict[this._onConflict.length - 1].ignore = true;
        return this;
    }
    merge(data) {
        if (!this._onConflict) {
            throw new Error('You need to call `qb.onConflict()` first to use `qb.merge()`');
        }
        this._onConflict[this._onConflict.length - 1].merge = data;
        return this;
    }
    /**
     * @internal
     */
    populate(populate, populateWhere) {
        this._populate = populate;
        this._populateWhere = populateWhere;
        return this;
    }
    /**
     * @internal
     */
    ref(field) {
        return this.knex.ref(field);
    }
    raw(sql, bindings = []) {
        const raw = this.knex.raw(sql, bindings);
        raw.__raw = true; // tag it as there is now way to check via `instanceof`
        return raw;
    }
    limit(limit, offset = 0) {
        this._limit = limit;
        if (offset) {
            this.offset(offset);
        }
        return this;
    }
    offset(offset) {
        this._offset = offset;
        return this;
    }
    withSchema(schema) {
        this._schema = schema;
        return this;
    }
    setLockMode(mode, tables) {
        if (mode != null && mode !== core_1.LockMode.OPTIMISTIC && !this.context) {
            throw core_1.ValidationError.transactionRequired();
        }
        this.lockMode = mode;
        this.lockTables = tables;
        return this;
    }
    setFlushMode(flushMode) {
        this.flushMode = flushMode;
        return this;
    }
    setFlag(flag) {
        this.flags.add(flag);
        return this;
    }
    unsetFlag(flag) {
        this.flags.delete(flag);
        return this;
    }
    cache(config = true) {
        this._cache = config;
        return this;
    }
    /**
     * Adds index hint to the FROM clause.
     */
    indexHint(sql) {
        this._indexHint = sql;
        return this;
    }
    from(target, aliasName) {
        if (target instanceof QueryBuilder) {
            this.fromSubQuery(target, aliasName);
        }
        else {
            const entityName = core_1.Utils.className(target);
            if (aliasName && this._mainAlias && entityName !== this._mainAlias.aliasName) {
                throw new Error(`Cannot override the alias to '${aliasName}' since a query already contains references to '${this._mainAlias.aliasName}'`);
            }
            this.fromEntityName(entityName, aliasName);
        }
        return this;
    }
    getKnexQuery() {
        this.finalize();
        const qb = this.getQueryBase();
        core_1.Utils.runIfNotEmpty(() => this.helper.appendQueryCondition(this.type, this._cond, qb), this._cond && !this._onConflict);
        core_1.Utils.runIfNotEmpty(() => qb.groupBy(this.prepareFields(this._groupBy, 'groupBy')), this._groupBy);
        core_1.Utils.runIfNotEmpty(() => this.helper.appendQueryCondition(this.type, this._having, qb, undefined, 'having'), this._having);
        core_1.Utils.runIfNotEmpty(() => {
            const queryOrder = this.helper.getQueryOrder(this.type, this._orderBy, this._populateMap);
            if (queryOrder) {
                return qb.orderByRaw(queryOrder);
            }
        }, this._orderBy);
        core_1.Utils.runIfNotEmpty(() => qb.limit(this._limit), this._limit != null);
        core_1.Utils.runIfNotEmpty(() => qb.offset(this._offset), this._offset);
        core_1.Utils.runIfNotEmpty(() => this.helper.appendOnConflictClause(this.type, this._onConflict, qb), this._onConflict);
        if (this.type === enums_1.QueryType.TRUNCATE && this.platform.usesCascadeStatement()) {
            return this.knex.raw(qb.toSQL().toNative().sql + ' cascade');
        }
        if (this.lockMode) {
            this.helper.getLockSQL(qb, this.lockMode, this.lockTables);
        }
        this.helper.finalize(this.type, qb, this.mainAlias.metadata);
        return qb;
    }
    /**
     * Returns the query with parameters as wildcards.
     */
    getQuery() {
        return this.getKnexQuery().toSQL().toNative().sql;
    }
    /**
     * Returns the list of all parameters for this query.
     */
    getParams() {
        return this.getKnexQuery().toSQL().toNative().bindings;
    }
    /**
     * Returns raw interpolated query string with all the parameters inlined.
     */
    getFormattedQuery() {
        const query = this.getKnexQuery().toSQL();
        return this.platform.formatQuery(query.sql, query.bindings);
    }
    /**
     * @internal
     */
    getAliasForJoinPath(path) {
        if (!path || path === this.mainAlias.entityName) {
            return this.mainAlias.aliasName;
        }
        const join = Object.values(this._joins).find(j => j.path === path);
        if (path.endsWith('[pivot]') && join) {
            return join.alias;
        }
        return join?.inverseAlias || join?.alias;
    }
    /**
     * @internal
     */
    getNextAlias(entityName = 'e') {
        return this.driver.config.getNamingStrategy().aliasName(entityName, this.aliasCounter++);
    }
    /**
     * @internal
     */
    getAliasMap() {
        return Object.fromEntries(Object.entries(this._aliases).map(([key, value]) => [key, value.entityName]));
    }
    /**
     * Executes this QB and returns the raw results, mapped to the property names (unless disabled via last parameter).
     * Use `method` to specify what kind of result you want to get (array/single/meta).
     */
    async execute(method = 'all', mapResults = true) {
        if (!this.connectionType && method !== 'run' && [enums_1.QueryType.INSERT, enums_1.QueryType.UPDATE, enums_1.QueryType.DELETE, enums_1.QueryType.TRUNCATE].includes(this.type)) {
            this.connectionType = 'write';
        }
        const query = this.getKnexQuery().toSQL();
        const cached = await this.em?.tryCache(this.mainAlias.entityName, this._cache, ['qb.execute', query.sql, query.bindings, method]);
        if (cached?.data) {
            return cached.data;
        }
        const type = this.connectionType || (method === 'run' ? 'write' : 'read');
        const res = await this.driver.getConnection(type).execute(query.sql, query.bindings, method, this.context);
        const meta = this.mainAlias.metadata;
        if (!mapResults || !meta) {
            await this.em?.storeCache(this._cache, cached, res);
            return res;
        }
        if (method === 'all' && Array.isArray(res)) {
            const map = {};
            const mapped = res.map(r => this.driver.mapResult(r, meta, this._populate, this, map));
            await this.em?.storeCache(this._cache, cached, mapped);
            return mapped;
        }
        const mapped = this.driver.mapResult(res, meta, this._populate, this);
        await this.em?.storeCache(this._cache, cached, mapped);
        return mapped;
    }
    /**
     * Alias for `qb.getResultList()`
     */
    async getResult() {
        return this.getResultList();
    }
    /**
     * Executes the query, returning array of results
     */
    async getResultList() {
        await this.em.tryFlush(this.mainAlias.entityName, { flushMode: this.flushMode });
        let res = await this.execute('all', true);
        if (this._joinedProps.size > 0) {
            res = this.driver.mergeJoinedResult(res, this.mainAlias.metadata);
        }
        return res.map(r => this.em.map(this.mainAlias.entityName, r, { schema: this._schema }));
    }
    /**
     * Executes the query, returning the first result or null
     */
    async getSingleResult() {
        const res = await this.getResultList();
        return res[0] || null;
    }
    /**
     * Executes count query (without offset and limit), returning total count of results
     */
    async getCount(field, distinct) {
        let res;
        if (this.type === enums_1.QueryType.COUNT) {
            res = await this.execute('get', false);
        }
        else {
            const qb = this.clone();
            qb.count(field, distinct ?? qb.hasToManyJoins()).limit(undefined).offset(undefined).orderBy([]);
            res = await qb.execute('get', false);
        }
        return res ? +res.count : 0;
    }
    /**
     * Provides promise-like interface so we can await the QB instance.
     */
    then(onfulfilled, onrejected) {
        return this.getInnerPromise().then(onfulfilled, onrejected);
    }
    getInnerPromise() {
        if (!this.innerPromise) {
            this.innerPromise = (async () => {
                switch (this.type) {
                    case enums_1.QueryType.INSERT:
                    case enums_1.QueryType.UPDATE:
                    case enums_1.QueryType.DELETE:
                    case enums_1.QueryType.TRUNCATE:
                        return this.execute('run');
                    case enums_1.QueryType.SELECT:
                        return this.getResultList();
                    case enums_1.QueryType.COUNT:
                        return this.getCount();
                }
            })();
        }
        return this.innerPromise;
    }
    /**
     * Returns knex instance with sub-query aliased with given alias.
     * You can provide `EntityName.propName` as alias, then the field name will be used based on the metadata
     */
    as(alias) {
        const qb = this.getKnexQuery();
        if (alias.includes('.')) {
            const [a, f] = alias.split('.');
            const meta = this.metadata.find(a);
            /* istanbul ignore next */
            alias = meta?.properties[f]?.fieldNames[0] ?? alias;
        }
        return qb.as(alias);
    }
    clone() {
        const qb = new QueryBuilder(this.mainAlias.entityName, this.metadata, this.driver, this.context, this.mainAlias.aliasName, this.connectionType, this.em);
        Object.assign(qb, this);
        // clone array/object properties
        const properties = [
            'flags', '_populate', '_populateWhere', '_populateMap', '_joins', '_joinedProps', '_aliases', '_cond', '_data', '_orderBy',
            '_schema', '_indexHint', '_cache', 'subQueries', 'lockMode', 'lockTables',
        ];
        properties.forEach(prop => qb[prop] = core_1.Utils.copy(this[prop]));
        /* istanbul ignore else */
        if (this._fields) {
            qb._fields = [...this._fields];
        }
        qb.finalized = false;
        return qb;
    }
    getKnex() {
        const qb = this.knex.queryBuilder();
        const { subQuery, aliasName, entityName } = this.mainAlias;
        const ref = subQuery ? subQuery : this.knex.ref(this.helper.getTableName(entityName));
        if (this.finalized && (this._explicitAlias || this.helper.isTableNameAliasRequired(this.type))) {
            ref.as(aliasName);
        }
        const schema = this.getSchema(this.mainAlias);
        if (schema) {
            ref.withSchema(schema);
        }
        qb.from(ref);
        if (this.context) {
            qb.transacting(this.context);
        }
        return qb;
    }
    joinReference(field, alias, cond, type, path) {
        const [fromAlias, fromField] = this.helper.splitField(field);
        const entityName = this._aliases[fromAlias]?.entityName;
        const meta = this.metadata.get(entityName);
        const prop = meta.properties[fromField];
        if (!prop) {
            throw new Error(`Trying to join ${field}, but ${fromField} is not a defined relation on ${meta.className}`);
        }
        this.createAlias(prop.type, alias);
        cond = core_1.QueryHelper.processWhere({
            where: cond,
            entityName: this.mainAlias.entityName,
            metadata: this.metadata,
            platform: this.platform,
            aliasMap: this.getAliasMap(),
            aliased: !this.type || [enums_1.QueryType.SELECT, enums_1.QueryType.COUNT].includes(this.type),
        });
        let aliasedName = `${fromAlias}.${prop.name}#${alias}`;
        path ?? (path = `${(Object.values(this._joins).find(j => j.alias === fromAlias)?.path ?? entityName)}.${prop.name}`);
        if (prop.reference === core_1.ReferenceType.ONE_TO_MANY) {
            this._joins[aliasedName] = this.helper.joinOneToReference(prop, fromAlias, alias, type, cond);
        }
        else if (prop.reference === core_1.ReferenceType.MANY_TO_MANY) {
            let pivotAlias = alias;
            if (type !== 'pivotJoin') {
                const oldPivotAlias = this.getAliasForJoinPath(path + '[pivot]');
                pivotAlias = oldPivotAlias ?? this.getNextAlias(prop.pivotEntity);
                aliasedName = `${fromAlias}.${prop.name}#${pivotAlias}`;
            }
            const joins = this.helper.joinManyToManyReference(prop, fromAlias, alias, pivotAlias, type, cond, path);
            Object.assign(this._joins, joins);
            this.createAlias(prop.pivotEntity, pivotAlias);
        }
        else if (prop.reference === core_1.ReferenceType.ONE_TO_ONE) {
            this._joins[aliasedName] = this.helper.joinOneToReference(prop, fromAlias, alias, type, cond);
        }
        else { // MANY_TO_ONE
            this._joins[aliasedName] = this.helper.joinManyToOneReference(prop, fromAlias, alias, type, cond);
        }
        if (!this._joins[aliasedName].path && path) {
            this._joins[aliasedName].path = path;
        }
        return prop;
    }
    prepareFields(fields, type = 'where') {
        const ret = [];
        fields.forEach(field => {
            if (!core_1.Utils.isString(field)) {
                return ret.push(field);
            }
            const join = Object.keys(this._joins).find(k => field === k.substring(0, k.indexOf('#')));
            if (join && type === 'where') {
                return ret.push(...this.helper.mapJoinColumns(this.type, this._joins[join]));
            }
            const [a, f] = this.helper.splitField(field);
            const prop = this.helper.getProperty(f, a);
            if (prop && [core_1.ReferenceType.ONE_TO_MANY, core_1.ReferenceType.MANY_TO_MANY].includes(prop.reference)) {
                return;
            }
            if (prop?.embedded) {
                const fieldName = this.helper.mapper(prop.fieldNames[0], this.type);
                ret.push(fieldName);
                return;
            }
            if (prop?.reference === core_1.ReferenceType.EMBEDDED) {
                if (prop.object) {
                    ret.push(this.helper.mapper(prop.fieldNames[0], this.type));
                }
                else {
                    const nest = (prop) => {
                        for (const childProp of Object.values(prop.embeddedProps)) {
                            if (childProp.fieldNames) {
                                ret.push(this.helper.mapper(childProp.fieldNames[0], this.type));
                            }
                            else {
                                nest(childProp);
                            }
                        }
                    };
                    nest(prop);
                }
                return;
            }
            ret.push(this.helper.mapper(field, this.type));
        });
        const meta = this.mainAlias.metadata;
        /* istanbul ignore next */
        const requiresSQLConversion = meta?.props.filter(p => p.customType?.convertToJSValueSQL) ?? [];
        if (this.flags.has(core_1.QueryFlag.CONVERT_CUSTOM_TYPES) && (fields.includes('*') || fields.includes(`${this.mainAlias.aliasName}.*`)) && requiresSQLConversion.length > 0) {
            requiresSQLConversion.forEach(p => ret.push(this.helper.mapper(p.name, this.type)));
        }
        Object.keys(this._populateMap).forEach(f => {
            if (!fields.includes(f.replace(/#\w+$/, '')) && type === 'where') {
                const cols = this.helper.mapJoinColumns(this.type, this._joins[f]);
                ret.push(...cols);
            }
            if (this._joins[f].prop.reference !== core_1.ReferenceType.ONE_TO_ONE && this._joins[f].inverseJoinColumns) {
                this._joins[f].inverseJoinColumns.forEach(inverseJoinColumn => {
                    core_1.Utils.renameKey(this._cond, inverseJoinColumn, `${this._joins[f].alias}.${inverseJoinColumn}`);
                });
            }
        });
        return ret;
    }
    init(type, data, cond) {
        this.type = type;
        if ([enums_1.QueryType.UPDATE, enums_1.QueryType.DELETE].includes(type) && core_1.Utils.hasObjectKeys(this._cond)) {
            throw new Error(`You are trying to call \`qb.where().${type.toLowerCase()}()\`. Calling \`qb.${type.toLowerCase()}()\` before \`qb.where()\` is required.`);
        }
        if (!this.helper.isTableNameAliasRequired(type)) {
            delete this._fields;
        }
        if (data) {
            if (core_1.Utils.isEntity(data)) {
                data = (0, core_1.helper)(data).toJSON();
            }
            this._data = this.helper.processData(data, this.flags.has(core_1.QueryFlag.CONVERT_CUSTOM_TYPES));
        }
        if (cond) {
            this.where(cond);
        }
        return this;
    }
    getQueryBase() {
        const qb = this.getKnex();
        const schema = this.getSchema(this.mainAlias);
        if (schema) {
            qb.withSchema(schema);
        }
        if (this._indexHint) {
            const alias = this.helper.isTableNameAliasRequired(this.type) ? ` as ${this.platform.quoteIdentifier(this.mainAlias.aliasName)}` : '';
            const schemaQuoted = schema ? this.platform.quoteIdentifier(schema) + '.' : '';
            const tableName = schemaQuoted + this.platform.quoteIdentifier(this.helper.getTableName(this.mainAlias.entityName)) + alias;
            qb.from(this.knex.raw(`${tableName} ${this._indexHint}`));
        }
        switch (this.type) {
            case enums_1.QueryType.SELECT:
                qb.select(this.prepareFields(this._fields));
                if (this.flags.has(core_1.QueryFlag.DISTINCT)) {
                    qb.distinct();
                }
                this.helper.processJoins(qb, this._joins, schema);
                break;
            case enums_1.QueryType.COUNT: {
                const m = this.flags.has(core_1.QueryFlag.DISTINCT) ? 'countDistinct' : 'count';
                qb[m]({ count: this._fields.map(f => this.helper.mapper(f, this.type)) });
                this.helper.processJoins(qb, this._joins, schema);
                break;
            }
            case enums_1.QueryType.INSERT:
                qb.insert(this._data);
                break;
            case enums_1.QueryType.UPDATE:
                qb.update(this._data);
                this.helper.updateVersionProperty(qb, this._data);
                break;
            case enums_1.QueryType.DELETE:
                qb.delete();
                break;
            case enums_1.QueryType.TRUNCATE:
                qb.truncate();
                break;
        }
        return qb;
    }
    finalize() {
        if (this.finalized) {
            return;
        }
        if (!this.type) {
            this.select('*');
        }
        const meta = this.mainAlias.metadata;
        if (meta && this.flags.has(core_1.QueryFlag.AUTO_JOIN_ONE_TO_ONE_OWNER)) {
            const relationsToPopulate = this._populate.map(({ field }) => field);
            meta.relations
                .filter(prop => prop.reference === core_1.ReferenceType.ONE_TO_ONE && !prop.owner && !relationsToPopulate.includes(prop.name))
                .map(prop => ({ field: prop.name }))
                .forEach(item => this._populate.push(item));
        }
        this._populate.forEach(({ field }) => {
            const [fromAlias, fromField] = this.helper.splitField(field);
            const aliasedField = `${fromAlias}.${fromField}`;
            const join = Object.keys(this._joins).find(k => `${aliasedField}#${this._joins[k].alias}` === k);
            if (join && this._joins[join] && this.helper.isOneToOneInverse(fromField)) {
                return this._populateMap[join] = this._joins[join].alias;
            }
            if (this.metadata.find(field)?.pivotTable) { // pivot table entity
                this.autoJoinPivotTable(field);
            }
            else if (meta && this.helper.isOneToOneInverse(fromField)) {
                const prop = meta.properties[fromField];
                const alias = this.getNextAlias(prop.pivotEntity ?? prop.type);
                const aliasedName = `${fromAlias}.${prop.name}#${alias}`;
                this._joins[aliasedName] = this.helper.joinOneToReference(prop, this.mainAlias.aliasName, alias, 'leftJoin');
                this._populateMap[aliasedName] = this._joins[aliasedName].alias;
            }
        });
        if (meta && (this._fields?.includes('*') || this._fields?.includes(`${this.mainAlias.aliasName}.*`))) {
            meta.props
                .filter(prop => prop.formula && (!prop.lazy || this.flags.has(core_1.QueryFlag.INCLUDE_LAZY_FORMULAS)))
                .map(prop => {
                const alias = this.knex.ref(this.mainAlias.aliasName).toString();
                const aliased = this.knex.ref(prop.fieldNames[0]).toString();
                return `${prop.formula(alias)} as ${aliased}`;
            })
                .filter(field => !this._fields.includes(field))
                .forEach(field => this.addSelect(field));
        }
        core_1.QueryHelper.processObjectParams(this._data);
        core_1.QueryHelper.processObjectParams(this._cond);
        core_1.QueryHelper.processObjectParams(this._having);
        this.finalized = true;
        // automatically enable paginate flag when we detect to-many joins
        if (!this.flags.has(core_1.QueryFlag.DISABLE_PAGINATE) && this.hasToManyJoins()) {
            this.flags.add(core_1.QueryFlag.PAGINATE);
        }
        if (meta && this.flags.has(core_1.QueryFlag.PAGINATE) && (this._limit > 0 || this._offset > 0)) {
            this.wrapPaginateSubQuery(meta);
        }
        if (meta && (this.flags.has(core_1.QueryFlag.UPDATE_SUB_QUERY) || this.flags.has(core_1.QueryFlag.DELETE_SUB_QUERY))) {
            this.wrapModifySubQuery(meta);
        }
    }
    hasToManyJoins() {
        return Object.values(this._joins).some(join => {
            return [core_1.ReferenceType.ONE_TO_MANY, core_1.ReferenceType.MANY_TO_MANY].includes(join.prop.reference);
        });
    }
    wrapPaginateSubQuery(meta) {
        const pks = this.prepareFields(meta.primaryKeys, 'sub-query');
        const subQuery = this.clone().select(pks).groupBy(pks).limit(this._limit);
        if (this._offset) {
            subQuery.offset(this._offset);
        }
        if (this._orderBy.length > 0) {
            const orderBy = [];
            for (const orderMap of this._orderBy) {
                for (const [field, direction] of Object.entries(orderMap)) {
                    const [a, f] = this.helper.splitField(field);
                    const prop = this.helper.getProperty(f, a);
                    const type = this.platform.castColumn(prop);
                    orderBy.push({
                        [`min(${this.ref(this.helper.mapper(field, this.type, undefined, null))}${type})`]: direction,
                    });
                }
            }
            subQuery.orderBy(orderBy);
        }
        subQuery.finalized = true;
        const knexQuery = subQuery.as(this.mainAlias.aliasName).clearSelect().select(pks);
        // multiple sub-queries are needed to get around mysql limitations with order by + limit + where in + group by (o.O)
        // https://stackoverflow.com/questions/17892762/mysql-this-version-of-mysql-doesnt-yet-support-limit-in-all-any-some-subqu
        const subSubQuery = this.getKnex().select(pks).from(knexQuery);
        this._limit = undefined;
        this._offset = undefined;
        const cond = this._cond;
        this.select(this._fields).where({ [core_1.Utils.getPrimaryKeyHash(meta.primaryKeys)]: { $in: subSubQuery } });
        if (this._populateWhere === core_1.PopulateHint.INFER) {
            this.andWhere(cond);
        }
        else if (typeof this._populateWhere === 'object') {
            this.andWhere(this._populateWhere);
        }
    }
    wrapModifySubQuery(meta) {
        const subQuery = this.clone();
        subQuery.finalized = true;
        // wrap one more time to get around MySQL limitations
        // https://stackoverflow.com/questions/45494/mysql-error-1093-cant-specify-target-table-for-update-in-from-clause
        const subSubQuery = this.getKnex().select(this.prepareFields(meta.primaryKeys)).from(subQuery.as(this.mainAlias.aliasName));
        const method = this.flags.has(core_1.QueryFlag.UPDATE_SUB_QUERY) ? 'update' : 'delete';
        this._cond = {}; // otherwise we would trigger validation error
        this[method](this._data).where({
            [core_1.Utils.getPrimaryKeyHash(meta.primaryKeys)]: { $in: subSubQuery },
        });
    }
    autoJoinPivotTable(field) {
        const pivotMeta = this.metadata.find(field);
        const owner = pivotMeta.relations[0];
        const inverse = pivotMeta.relations[1];
        const prop = this._cond[pivotMeta.name + '.' + owner.name] || this._orderBy[pivotMeta.name + '.' + owner.name] ? inverse : owner;
        const pivotAlias = this.getNextAlias(pivotMeta.name);
        this._joins[field] = this.helper.joinPivotTable(field, prop, this.mainAlias.aliasName, pivotAlias, 'leftJoin');
        core_1.Utils.renameKey(this._cond, `${field}.${owner.name}`, core_1.Utils.getPrimaryKeyHash(owner.fieldNames.map(fieldName => `${pivotAlias}.${fieldName}`)));
        core_1.Utils.renameKey(this._cond, `${field}.${inverse.name}`, core_1.Utils.getPrimaryKeyHash(inverse.fieldNames.map(fieldName => `${pivotAlias}.${fieldName}`)));
        this._populateMap[field] = this._joins[field].alias;
    }
    getSchema(alias) {
        const { metadata } = alias;
        const metaSchema = metadata?.schema && metadata.schema !== '*' ? metadata.schema : undefined;
        return this._schema ?? metaSchema ?? this.em?.config.get('schema');
    }
    createAlias(entityName, aliasName, subQuery) {
        const metadata = this.metadata.find(entityName);
        const alias = { aliasName, entityName, metadata, subQuery };
        this._aliases[aliasName] = alias;
        return alias;
    }
    createMainAlias(entityName, aliasName, subQuery) {
        this._mainAlias = this.createAlias(entityName, aliasName, subQuery);
        this._helper = this.createQueryBuilderHelper();
        return this._mainAlias;
    }
    fromSubQuery(target, aliasName) {
        const subQuery = target.getKnexQuery();
        const { entityName } = target.mainAlias;
        aliasName ?? (aliasName = this.getNextAlias(entityName));
        this.createMainAlias(entityName, aliasName, subQuery);
    }
    fromEntityName(entityName, aliasName) {
        aliasName ?? (aliasName = this._mainAlias?.aliasName ?? this.getNextAlias(entityName));
        this.createMainAlias(entityName, aliasName);
    }
    createQueryBuilderHelper() {
        return new QueryBuilderHelper_1.QueryBuilderHelper(this.mainAlias.entityName, this.mainAlias.aliasName, this._aliases, this.subQueries, this.knex, this.driver);
    }
    throwNoFromClauseError() {
        throw new Error(`Cannot proceed to build a query because the main alias is not set.`);
    }
}
exports.QueryBuilder = QueryBuilder;
